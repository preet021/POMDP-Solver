#!/usr/local/bin/perl -w
#
# Copyright (c) 1996-2005, Carnegie Mellon University. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you
# may not use this file except in compliance with the License. You may
# obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.

######################################################################

use strict;
use IO::Handle;
use Cwd;

use vars qw( $OUTPUT_DIR $SRC_DIR );

BEGIN {
    my $membersDir = $ENV{"FIRE_MEMBERS_DIR"};
    if (!defined($membersDir)) {
	die "$ARGV[0]: you must source fireenv";
    }
    $OUTPUT_DIR = "$membersDir/software/data/Docs";
    $SRC_DIR = cwd;
}

&main();

sub recurseDirs {
    my $thisDir = shift;

    local(*CWD);
    if (!opendir(CWD, ".")) {
	warn "$ARGV[0]: couldn't opendir $thisDir: $!\n";
	return [];
    }
    my @docDirs = ();
    my @fileList = sort readdir(CWD);
    for my $file (@fileList) {
	next if $file =~ /^\./;
	next if $file eq 'CVS';
	next if $file eq 'gen';
	next if $file eq 'obj';
	if (-d $file) {
	    my $oldDir = cwd;
	    if (chdir($file)) {
		if (-f "GNUmakefile") {
		    push @docDirs, [$file, &recurseDirs("$thisDir/$file")];
		}
		chdir($oldDir);
	    } else {
		warn "$ARGV[0]: couldn't cd to $thisDir/$file: $!\n";
	    }
	}
    }
    return \@docDirs;
}

sub printDirs {
    my $thisDir = shift;
    my $docDirs = shift;
    for (@{$docDirs}) {
	my ($dir, $subDocDirs) = @{$_};
	print "$thisDir/$dir\n";
	&printDirs("$thisDir/$dir", $subDocDirs);
    }
}

sub makeHeaderList {
    my $thisDir = shift;
    my $docDirs = shift;
    my $indent = shift;

print HDR <<"EOF";
$indent<ul>
EOF
    for (@{$docDirs}) {
	my ($dir, $subDocDirs) = @{$_};
	my $fullDir = "$thisDir/$dir";
	$fullDir =~ s:^\./::;

	my $fileToLink = "$fullDir/hierarchy.html";
	if (! (-e "$OUTPUT_DIR/$fileToLink")) {
	    $fileToLink = "$fullDir/files.html";
	}

	print HDR <<"EOF";
$indent  <li> <a href="$fileToLink">$dir</a>
EOF
        if (($#{$subDocDirs}+1) > 0) {
	    &makeHeaderList($fullDir,$subDocDirs,$indent."  ");
	}
    }
print HDR <<"EOF";
$indent</ul>
EOF
    
}

sub makeHeader {
    my $docDirs = shift;

    my $hdrFile = "$OUTPUT_DIR/index.html";
    open(HDR, ">$hdrFile") or die "couldn't open $hdrFile for writing: $!\n";

    my $title = "Auto-Generated Documentation";
    print HDR <<"EOF";
<html><head><title>$title</title></head>
<body>
<h1>$title</h1>
<h2>Click on a directory name to see the doxygen docs for that directory</h2>
EOF

    $docDirs = [['src', $docDirs]];
    &makeHeaderList(".",$docDirs,"");

    my $date = `date`;
    print HDR <<"EOF";
<p><hr>
<address>
  This directory tree automatically generated by
  src/Build/doxygenRecurse.perl, $date
</address>
</body></html>
EOF

}

sub safeMakeDir {
    my $dir = shift;
    if (-d $dir) { return; }
    mkdir($dir,0777) or die "couldn't mkdir $dir: $!\n";
}

sub topRelLocation {
    my $fullDir = shift;
    my $countMatch = ($fullDir =~ s:/:/:g);
    return (("../" x ($countMatch+1)) . "..");
}

sub makeDocsRecurse {
    my $thisDir = shift;
    my $docDirs = shift;
    for (@{$docDirs}) {
	my ($dir, $subDocDirs) = @{$_};
	my $fullDir = "$thisDir/$dir";
	$fullDir =~ s:^\./::;

	# create output directory
	my $thisOutputDir = "$OUTPUT_DIR/src/$fullDir";
	&safeMakeDir($thisOutputDir);

	# create gen directory (if it doesn't exist)
	&safeMakeDir("$fullDir/gen");

	# make a symlink in the right src directory, to the output directory
	my $linkName = "$fullDir/gen/html";
	if (-l $linkName) {
	    unlink $linkName or die "couldn't delete $linkName: $!\n";
	} elsif (-d $linkName) {
	    system "rm -rf $linkName"
		and die "couldn't delete $linkName: $!\n";
	}

	symlink $thisOutputDir, $linkName
	    or die "couldn't link $thisOutputDir to $linkName: $!\n";
	
	# generate the docs
	my $oldDir = cwd;
	chdir $fullDir or die "couldn't cd to $fullDir: $!\n";
	print ".";
	#system("pwd; echo run doxygen $SRC_DIR/Build/doxygen.cfg");
	my $indexPageLoc = &topRelLocation($fullDir) . "/index.html";
	system("doxygen -i $indexPageLoc -p '$fullDir Directory' ".
                 "$SRC_DIR/Build/doxygen.cfg");
	chdir $oldDir or die "couldn't cd back to $oldDir: $!\n";

	&makeDocsRecurse("$thisDir/$dir", $subDocDirs);
    }
}

sub makeDocs {
    my $thisDir = shift;
    my $docDirs = shift;

    &safeMakeDir($OUTPUT_DIR);
    &safeMakeDir("$OUTPUT_DIR/src");
    &makeDocsRecurse($thisDir,$docDirs);
}

sub main {
    umask 000;
    STDOUT->autoflush(1);
    print "generating list of source directories\n";
    my $docDirs = &recurseDirs(".");
    #&printDirs(".",$docDirs);
    print "running doxygen (this may take a while)";
    &makeDocs(".",$docDirs);
    print "\n";
    print "creating top level doc index\n";
    &makeHeader($docDirs);
    print "doc build complete.  view results at\n";
    print "file:$OUTPUT_DIR/index.html\n";
}
